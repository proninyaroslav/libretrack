// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'add_parcels_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AddParcelsState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            TrackingNumbers trackingNumbers, ParcelNames parcelNames)
        initial,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        loaded,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        fieldChanged,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        customerTypeChanged,
    required TResult Function() adding,
    required TResult Function(List<TrackNumberInfo> addedTrackInfoList) added,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        validationFailed,
    required TResult Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)
        addFailed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames)?
        initial,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        loaded,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        fieldChanged,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        customerTypeChanged,
    TResult? Function()? adding,
    TResult? Function(List<TrackNumberInfo> addedTrackInfoList)? added,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        validationFailed,
    TResult? Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)?
        addFailed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames)?
        initial,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        loaded,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        fieldChanged,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        customerTypeChanged,
    TResult Function()? adding,
    TResult Function(List<TrackNumberInfo> addedTrackInfoList)? added,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        validationFailed,
    TResult Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)?
        addFailed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddParcelsStateInitial value) initial,
    required TResult Function(AddParcelsStateLoaded value) loaded,
    required TResult Function(AddParcelsStateFieldChanged value) fieldChanged,
    required TResult Function(AddParcelsStateCustomerTypeChanged value)
        customerTypeChanged,
    required TResult Function(AddParcelsStateAdding value) adding,
    required TResult Function(AddParcelsStateAdded value) added,
    required TResult Function(AddParcelsStateValidationFailed value)
        validationFailed,
    required TResult Function(AddParcelsStateAddFailed value) addFailed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddParcelsStateInitial value)? initial,
    TResult? Function(AddParcelsStateLoaded value)? loaded,
    TResult? Function(AddParcelsStateFieldChanged value)? fieldChanged,
    TResult? Function(AddParcelsStateCustomerTypeChanged value)?
        customerTypeChanged,
    TResult? Function(AddParcelsStateAdding value)? adding,
    TResult? Function(AddParcelsStateAdded value)? added,
    TResult? Function(AddParcelsStateValidationFailed value)? validationFailed,
    TResult? Function(AddParcelsStateAddFailed value)? addFailed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddParcelsStateInitial value)? initial,
    TResult Function(AddParcelsStateLoaded value)? loaded,
    TResult Function(AddParcelsStateFieldChanged value)? fieldChanged,
    TResult Function(AddParcelsStateCustomerTypeChanged value)?
        customerTypeChanged,
    TResult Function(AddParcelsStateAdding value)? adding,
    TResult Function(AddParcelsStateAdded value)? added,
    TResult Function(AddParcelsStateValidationFailed value)? validationFailed,
    TResult Function(AddParcelsStateAddFailed value)? addFailed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddParcelsStateCopyWith<$Res> {
  factory $AddParcelsStateCopyWith(
          AddParcelsState value, $Res Function(AddParcelsState) then) =
      _$AddParcelsStateCopyWithImpl<$Res, AddParcelsState>;
}

/// @nodoc
class _$AddParcelsStateCopyWithImpl<$Res, $Val extends AddParcelsState>
    implements $AddParcelsStateCopyWith<$Res> {
  _$AddParcelsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$AddParcelsStateInitialImplCopyWith<$Res> {
  factory _$$AddParcelsStateInitialImplCopyWith(
          _$AddParcelsStateInitialImpl value,
          $Res Function(_$AddParcelsStateInitialImpl) then) =
      __$$AddParcelsStateInitialImplCopyWithImpl<$Res>;
  @useResult
  $Res call({TrackingNumbers trackingNumbers, ParcelNames parcelNames});

  $TrackingNumbersCopyWith<$Res> get trackingNumbers;
  $ParcelNamesCopyWith<$Res> get parcelNames;
}

/// @nodoc
class __$$AddParcelsStateInitialImplCopyWithImpl<$Res>
    extends _$AddParcelsStateCopyWithImpl<$Res, _$AddParcelsStateInitialImpl>
    implements _$$AddParcelsStateInitialImplCopyWith<$Res> {
  __$$AddParcelsStateInitialImplCopyWithImpl(
      _$AddParcelsStateInitialImpl _value,
      $Res Function(_$AddParcelsStateInitialImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? trackingNumbers = null,
    Object? parcelNames = null,
  }) {
    return _then(_$AddParcelsStateInitialImpl(
      trackingNumbers: null == trackingNumbers
          ? _value.trackingNumbers
          : trackingNumbers // ignore: cast_nullable_to_non_nullable
              as TrackingNumbers,
      parcelNames: null == parcelNames
          ? _value.parcelNames
          : parcelNames // ignore: cast_nullable_to_non_nullable
              as ParcelNames,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $TrackingNumbersCopyWith<$Res> get trackingNumbers {
    return $TrackingNumbersCopyWith<$Res>(_value.trackingNumbers, (value) {
      return _then(_value.copyWith(trackingNumbers: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ParcelNamesCopyWith<$Res> get parcelNames {
    return $ParcelNamesCopyWith<$Res>(_value.parcelNames, (value) {
      return _then(_value.copyWith(parcelNames: value));
    });
  }
}

/// @nodoc

class _$AddParcelsStateInitialImpl
    with DiagnosticableTreeMixin
    implements AddParcelsStateInitial {
  const _$AddParcelsStateInitialImpl(
      {this.trackingNumbers = const TrackingNumbers(),
      this.parcelNames = const ParcelNames()});

  @override
  @JsonKey()
  final TrackingNumbers trackingNumbers;
  @override
  @JsonKey()
  final ParcelNames parcelNames;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddParcelsState.initial(trackingNumbers: $trackingNumbers, parcelNames: $parcelNames)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AddParcelsState.initial'))
      ..add(DiagnosticsProperty('trackingNumbers', trackingNumbers))
      ..add(DiagnosticsProperty('parcelNames', parcelNames));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddParcelsStateInitialImpl &&
            (identical(other.trackingNumbers, trackingNumbers) ||
                other.trackingNumbers == trackingNumbers) &&
            (identical(other.parcelNames, parcelNames) ||
                other.parcelNames == parcelNames));
  }

  @override
  int get hashCode => Object.hash(runtimeType, trackingNumbers, parcelNames);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddParcelsStateInitialImplCopyWith<_$AddParcelsStateInitialImpl>
      get copyWith => __$$AddParcelsStateInitialImplCopyWithImpl<
          _$AddParcelsStateInitialImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            TrackingNumbers trackingNumbers, ParcelNames parcelNames)
        initial,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        loaded,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        fieldChanged,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        customerTypeChanged,
    required TResult Function() adding,
    required TResult Function(List<TrackNumberInfo> addedTrackInfoList) added,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        validationFailed,
    required TResult Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)
        addFailed,
  }) {
    return initial(trackingNumbers, parcelNames);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames)?
        initial,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        loaded,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        fieldChanged,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        customerTypeChanged,
    TResult? Function()? adding,
    TResult? Function(List<TrackNumberInfo> addedTrackInfoList)? added,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        validationFailed,
    TResult? Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)?
        addFailed,
  }) {
    return initial?.call(trackingNumbers, parcelNames);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames)?
        initial,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        loaded,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        fieldChanged,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        customerTypeChanged,
    TResult Function()? adding,
    TResult Function(List<TrackNumberInfo> addedTrackInfoList)? added,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        validationFailed,
    TResult Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)?
        addFailed,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(trackingNumbers, parcelNames);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddParcelsStateInitial value) initial,
    required TResult Function(AddParcelsStateLoaded value) loaded,
    required TResult Function(AddParcelsStateFieldChanged value) fieldChanged,
    required TResult Function(AddParcelsStateCustomerTypeChanged value)
        customerTypeChanged,
    required TResult Function(AddParcelsStateAdding value) adding,
    required TResult Function(AddParcelsStateAdded value) added,
    required TResult Function(AddParcelsStateValidationFailed value)
        validationFailed,
    required TResult Function(AddParcelsStateAddFailed value) addFailed,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddParcelsStateInitial value)? initial,
    TResult? Function(AddParcelsStateLoaded value)? loaded,
    TResult? Function(AddParcelsStateFieldChanged value)? fieldChanged,
    TResult? Function(AddParcelsStateCustomerTypeChanged value)?
        customerTypeChanged,
    TResult? Function(AddParcelsStateAdding value)? adding,
    TResult? Function(AddParcelsStateAdded value)? added,
    TResult? Function(AddParcelsStateValidationFailed value)? validationFailed,
    TResult? Function(AddParcelsStateAddFailed value)? addFailed,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddParcelsStateInitial value)? initial,
    TResult Function(AddParcelsStateLoaded value)? loaded,
    TResult Function(AddParcelsStateFieldChanged value)? fieldChanged,
    TResult Function(AddParcelsStateCustomerTypeChanged value)?
        customerTypeChanged,
    TResult Function(AddParcelsStateAdding value)? adding,
    TResult Function(AddParcelsStateAdded value)? added,
    TResult Function(AddParcelsStateValidationFailed value)? validationFailed,
    TResult Function(AddParcelsStateAddFailed value)? addFailed,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class AddParcelsStateInitial implements AddParcelsState {
  const factory AddParcelsStateInitial(
      {final TrackingNumbers trackingNumbers,
      final ParcelNames parcelNames}) = _$AddParcelsStateInitialImpl;

  TrackingNumbers get trackingNumbers;
  ParcelNames get parcelNames;
  @JsonKey(ignore: true)
  _$$AddParcelsStateInitialImplCopyWith<_$AddParcelsStateInitialImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddParcelsStateLoadedImplCopyWith<$Res> {
  factory _$$AddParcelsStateLoadedImplCopyWith(
          _$AddParcelsStateLoadedImpl value,
          $Res Function(_$AddParcelsStateLoadedImpl) then) =
      __$$AddParcelsStateLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {TrackingNumbers trackingNumbers,
      ParcelNames parcelNames,
      CustomerType customerType});

  $TrackingNumbersCopyWith<$Res> get trackingNumbers;
  $ParcelNamesCopyWith<$Res> get parcelNames;
}

/// @nodoc
class __$$AddParcelsStateLoadedImplCopyWithImpl<$Res>
    extends _$AddParcelsStateCopyWithImpl<$Res, _$AddParcelsStateLoadedImpl>
    implements _$$AddParcelsStateLoadedImplCopyWith<$Res> {
  __$$AddParcelsStateLoadedImplCopyWithImpl(_$AddParcelsStateLoadedImpl _value,
      $Res Function(_$AddParcelsStateLoadedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? trackingNumbers = null,
    Object? parcelNames = null,
    Object? customerType = null,
  }) {
    return _then(_$AddParcelsStateLoadedImpl(
      trackingNumbers: null == trackingNumbers
          ? _value.trackingNumbers
          : trackingNumbers // ignore: cast_nullable_to_non_nullable
              as TrackingNumbers,
      parcelNames: null == parcelNames
          ? _value.parcelNames
          : parcelNames // ignore: cast_nullable_to_non_nullable
              as ParcelNames,
      customerType: null == customerType
          ? _value.customerType
          : customerType // ignore: cast_nullable_to_non_nullable
              as CustomerType,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $TrackingNumbersCopyWith<$Res> get trackingNumbers {
    return $TrackingNumbersCopyWith<$Res>(_value.trackingNumbers, (value) {
      return _then(_value.copyWith(trackingNumbers: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ParcelNamesCopyWith<$Res> get parcelNames {
    return $ParcelNamesCopyWith<$Res>(_value.parcelNames, (value) {
      return _then(_value.copyWith(parcelNames: value));
    });
  }
}

/// @nodoc

class _$AddParcelsStateLoadedImpl
    with DiagnosticableTreeMixin
    implements AddParcelsStateLoaded {
  const _$AddParcelsStateLoadedImpl(
      {this.trackingNumbers = const TrackingNumbers(),
      this.parcelNames = const ParcelNames(),
      required this.customerType});

  @override
  @JsonKey()
  final TrackingNumbers trackingNumbers;
  @override
  @JsonKey()
  final ParcelNames parcelNames;
  @override
  final CustomerType customerType;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddParcelsState.loaded(trackingNumbers: $trackingNumbers, parcelNames: $parcelNames, customerType: $customerType)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AddParcelsState.loaded'))
      ..add(DiagnosticsProperty('trackingNumbers', trackingNumbers))
      ..add(DiagnosticsProperty('parcelNames', parcelNames))
      ..add(DiagnosticsProperty('customerType', customerType));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddParcelsStateLoadedImpl &&
            (identical(other.trackingNumbers, trackingNumbers) ||
                other.trackingNumbers == trackingNumbers) &&
            (identical(other.parcelNames, parcelNames) ||
                other.parcelNames == parcelNames) &&
            (identical(other.customerType, customerType) ||
                other.customerType == customerType));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, trackingNumbers, parcelNames, customerType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddParcelsStateLoadedImplCopyWith<_$AddParcelsStateLoadedImpl>
      get copyWith => __$$AddParcelsStateLoadedImplCopyWithImpl<
          _$AddParcelsStateLoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            TrackingNumbers trackingNumbers, ParcelNames parcelNames)
        initial,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        loaded,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        fieldChanged,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        customerTypeChanged,
    required TResult Function() adding,
    required TResult Function(List<TrackNumberInfo> addedTrackInfoList) added,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        validationFailed,
    required TResult Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)
        addFailed,
  }) {
    return loaded(trackingNumbers, parcelNames, customerType);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames)?
        initial,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        loaded,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        fieldChanged,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        customerTypeChanged,
    TResult? Function()? adding,
    TResult? Function(List<TrackNumberInfo> addedTrackInfoList)? added,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        validationFailed,
    TResult? Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)?
        addFailed,
  }) {
    return loaded?.call(trackingNumbers, parcelNames, customerType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames)?
        initial,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        loaded,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        fieldChanged,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        customerTypeChanged,
    TResult Function()? adding,
    TResult Function(List<TrackNumberInfo> addedTrackInfoList)? added,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        validationFailed,
    TResult Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)?
        addFailed,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(trackingNumbers, parcelNames, customerType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddParcelsStateInitial value) initial,
    required TResult Function(AddParcelsStateLoaded value) loaded,
    required TResult Function(AddParcelsStateFieldChanged value) fieldChanged,
    required TResult Function(AddParcelsStateCustomerTypeChanged value)
        customerTypeChanged,
    required TResult Function(AddParcelsStateAdding value) adding,
    required TResult Function(AddParcelsStateAdded value) added,
    required TResult Function(AddParcelsStateValidationFailed value)
        validationFailed,
    required TResult Function(AddParcelsStateAddFailed value) addFailed,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddParcelsStateInitial value)? initial,
    TResult? Function(AddParcelsStateLoaded value)? loaded,
    TResult? Function(AddParcelsStateFieldChanged value)? fieldChanged,
    TResult? Function(AddParcelsStateCustomerTypeChanged value)?
        customerTypeChanged,
    TResult? Function(AddParcelsStateAdding value)? adding,
    TResult? Function(AddParcelsStateAdded value)? added,
    TResult? Function(AddParcelsStateValidationFailed value)? validationFailed,
    TResult? Function(AddParcelsStateAddFailed value)? addFailed,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddParcelsStateInitial value)? initial,
    TResult Function(AddParcelsStateLoaded value)? loaded,
    TResult Function(AddParcelsStateFieldChanged value)? fieldChanged,
    TResult Function(AddParcelsStateCustomerTypeChanged value)?
        customerTypeChanged,
    TResult Function(AddParcelsStateAdding value)? adding,
    TResult Function(AddParcelsStateAdded value)? added,
    TResult Function(AddParcelsStateValidationFailed value)? validationFailed,
    TResult Function(AddParcelsStateAddFailed value)? addFailed,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class AddParcelsStateLoaded implements AddParcelsState {
  const factory AddParcelsStateLoaded(
      {final TrackingNumbers trackingNumbers,
      final ParcelNames parcelNames,
      required final CustomerType customerType}) = _$AddParcelsStateLoadedImpl;

  TrackingNumbers get trackingNumbers;
  ParcelNames get parcelNames;
  CustomerType get customerType;
  @JsonKey(ignore: true)
  _$$AddParcelsStateLoadedImplCopyWith<_$AddParcelsStateLoadedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddParcelsStateFieldChangedImplCopyWith<$Res> {
  factory _$$AddParcelsStateFieldChangedImplCopyWith(
          _$AddParcelsStateFieldChangedImpl value,
          $Res Function(_$AddParcelsStateFieldChangedImpl) then) =
      __$$AddParcelsStateFieldChangedImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {TrackingNumbers trackingNumbers,
      ParcelNames parcelNames,
      CustomerType customerType});

  $TrackingNumbersCopyWith<$Res> get trackingNumbers;
  $ParcelNamesCopyWith<$Res> get parcelNames;
}

/// @nodoc
class __$$AddParcelsStateFieldChangedImplCopyWithImpl<$Res>
    extends _$AddParcelsStateCopyWithImpl<$Res,
        _$AddParcelsStateFieldChangedImpl>
    implements _$$AddParcelsStateFieldChangedImplCopyWith<$Res> {
  __$$AddParcelsStateFieldChangedImplCopyWithImpl(
      _$AddParcelsStateFieldChangedImpl _value,
      $Res Function(_$AddParcelsStateFieldChangedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? trackingNumbers = null,
    Object? parcelNames = null,
    Object? customerType = null,
  }) {
    return _then(_$AddParcelsStateFieldChangedImpl(
      trackingNumbers: null == trackingNumbers
          ? _value.trackingNumbers
          : trackingNumbers // ignore: cast_nullable_to_non_nullable
              as TrackingNumbers,
      parcelNames: null == parcelNames
          ? _value.parcelNames
          : parcelNames // ignore: cast_nullable_to_non_nullable
              as ParcelNames,
      customerType: null == customerType
          ? _value.customerType
          : customerType // ignore: cast_nullable_to_non_nullable
              as CustomerType,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $TrackingNumbersCopyWith<$Res> get trackingNumbers {
    return $TrackingNumbersCopyWith<$Res>(_value.trackingNumbers, (value) {
      return _then(_value.copyWith(trackingNumbers: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ParcelNamesCopyWith<$Res> get parcelNames {
    return $ParcelNamesCopyWith<$Res>(_value.parcelNames, (value) {
      return _then(_value.copyWith(parcelNames: value));
    });
  }
}

/// @nodoc

class _$AddParcelsStateFieldChangedImpl
    with DiagnosticableTreeMixin
    implements AddParcelsStateFieldChanged {
  const _$AddParcelsStateFieldChangedImpl(
      {required this.trackingNumbers,
      required this.parcelNames,
      required this.customerType});

  @override
  final TrackingNumbers trackingNumbers;
  @override
  final ParcelNames parcelNames;
  @override
  final CustomerType customerType;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddParcelsState.fieldChanged(trackingNumbers: $trackingNumbers, parcelNames: $parcelNames, customerType: $customerType)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AddParcelsState.fieldChanged'))
      ..add(DiagnosticsProperty('trackingNumbers', trackingNumbers))
      ..add(DiagnosticsProperty('parcelNames', parcelNames))
      ..add(DiagnosticsProperty('customerType', customerType));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddParcelsStateFieldChangedImpl &&
            (identical(other.trackingNumbers, trackingNumbers) ||
                other.trackingNumbers == trackingNumbers) &&
            (identical(other.parcelNames, parcelNames) ||
                other.parcelNames == parcelNames) &&
            (identical(other.customerType, customerType) ||
                other.customerType == customerType));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, trackingNumbers, parcelNames, customerType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddParcelsStateFieldChangedImplCopyWith<_$AddParcelsStateFieldChangedImpl>
      get copyWith => __$$AddParcelsStateFieldChangedImplCopyWithImpl<
          _$AddParcelsStateFieldChangedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            TrackingNumbers trackingNumbers, ParcelNames parcelNames)
        initial,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        loaded,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        fieldChanged,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        customerTypeChanged,
    required TResult Function() adding,
    required TResult Function(List<TrackNumberInfo> addedTrackInfoList) added,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        validationFailed,
    required TResult Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)
        addFailed,
  }) {
    return fieldChanged(trackingNumbers, parcelNames, customerType);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames)?
        initial,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        loaded,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        fieldChanged,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        customerTypeChanged,
    TResult? Function()? adding,
    TResult? Function(List<TrackNumberInfo> addedTrackInfoList)? added,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        validationFailed,
    TResult? Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)?
        addFailed,
  }) {
    return fieldChanged?.call(trackingNumbers, parcelNames, customerType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames)?
        initial,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        loaded,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        fieldChanged,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        customerTypeChanged,
    TResult Function()? adding,
    TResult Function(List<TrackNumberInfo> addedTrackInfoList)? added,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        validationFailed,
    TResult Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)?
        addFailed,
    required TResult orElse(),
  }) {
    if (fieldChanged != null) {
      return fieldChanged(trackingNumbers, parcelNames, customerType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddParcelsStateInitial value) initial,
    required TResult Function(AddParcelsStateLoaded value) loaded,
    required TResult Function(AddParcelsStateFieldChanged value) fieldChanged,
    required TResult Function(AddParcelsStateCustomerTypeChanged value)
        customerTypeChanged,
    required TResult Function(AddParcelsStateAdding value) adding,
    required TResult Function(AddParcelsStateAdded value) added,
    required TResult Function(AddParcelsStateValidationFailed value)
        validationFailed,
    required TResult Function(AddParcelsStateAddFailed value) addFailed,
  }) {
    return fieldChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddParcelsStateInitial value)? initial,
    TResult? Function(AddParcelsStateLoaded value)? loaded,
    TResult? Function(AddParcelsStateFieldChanged value)? fieldChanged,
    TResult? Function(AddParcelsStateCustomerTypeChanged value)?
        customerTypeChanged,
    TResult? Function(AddParcelsStateAdding value)? adding,
    TResult? Function(AddParcelsStateAdded value)? added,
    TResult? Function(AddParcelsStateValidationFailed value)? validationFailed,
    TResult? Function(AddParcelsStateAddFailed value)? addFailed,
  }) {
    return fieldChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddParcelsStateInitial value)? initial,
    TResult Function(AddParcelsStateLoaded value)? loaded,
    TResult Function(AddParcelsStateFieldChanged value)? fieldChanged,
    TResult Function(AddParcelsStateCustomerTypeChanged value)?
        customerTypeChanged,
    TResult Function(AddParcelsStateAdding value)? adding,
    TResult Function(AddParcelsStateAdded value)? added,
    TResult Function(AddParcelsStateValidationFailed value)? validationFailed,
    TResult Function(AddParcelsStateAddFailed value)? addFailed,
    required TResult orElse(),
  }) {
    if (fieldChanged != null) {
      return fieldChanged(this);
    }
    return orElse();
  }
}

abstract class AddParcelsStateFieldChanged implements AddParcelsState {
  const factory AddParcelsStateFieldChanged(
          {required final TrackingNumbers trackingNumbers,
          required final ParcelNames parcelNames,
          required final CustomerType customerType}) =
      _$AddParcelsStateFieldChangedImpl;

  TrackingNumbers get trackingNumbers;
  ParcelNames get parcelNames;
  CustomerType get customerType;
  @JsonKey(ignore: true)
  _$$AddParcelsStateFieldChangedImplCopyWith<_$AddParcelsStateFieldChangedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddParcelsStateCustomerTypeChangedImplCopyWith<$Res> {
  factory _$$AddParcelsStateCustomerTypeChangedImplCopyWith(
          _$AddParcelsStateCustomerTypeChangedImpl value,
          $Res Function(_$AddParcelsStateCustomerTypeChangedImpl) then) =
      __$$AddParcelsStateCustomerTypeChangedImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {TrackingNumbers trackingNumbers,
      ParcelNames parcelNames,
      CustomerType customerType});

  $TrackingNumbersCopyWith<$Res> get trackingNumbers;
  $ParcelNamesCopyWith<$Res> get parcelNames;
}

/// @nodoc
class __$$AddParcelsStateCustomerTypeChangedImplCopyWithImpl<$Res>
    extends _$AddParcelsStateCopyWithImpl<$Res,
        _$AddParcelsStateCustomerTypeChangedImpl>
    implements _$$AddParcelsStateCustomerTypeChangedImplCopyWith<$Res> {
  __$$AddParcelsStateCustomerTypeChangedImplCopyWithImpl(
      _$AddParcelsStateCustomerTypeChangedImpl _value,
      $Res Function(_$AddParcelsStateCustomerTypeChangedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? trackingNumbers = null,
    Object? parcelNames = null,
    Object? customerType = null,
  }) {
    return _then(_$AddParcelsStateCustomerTypeChangedImpl(
      trackingNumbers: null == trackingNumbers
          ? _value.trackingNumbers
          : trackingNumbers // ignore: cast_nullable_to_non_nullable
              as TrackingNumbers,
      parcelNames: null == parcelNames
          ? _value.parcelNames
          : parcelNames // ignore: cast_nullable_to_non_nullable
              as ParcelNames,
      customerType: null == customerType
          ? _value.customerType
          : customerType // ignore: cast_nullable_to_non_nullable
              as CustomerType,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $TrackingNumbersCopyWith<$Res> get trackingNumbers {
    return $TrackingNumbersCopyWith<$Res>(_value.trackingNumbers, (value) {
      return _then(_value.copyWith(trackingNumbers: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ParcelNamesCopyWith<$Res> get parcelNames {
    return $ParcelNamesCopyWith<$Res>(_value.parcelNames, (value) {
      return _then(_value.copyWith(parcelNames: value));
    });
  }
}

/// @nodoc

class _$AddParcelsStateCustomerTypeChangedImpl
    with DiagnosticableTreeMixin
    implements AddParcelsStateCustomerTypeChanged {
  const _$AddParcelsStateCustomerTypeChangedImpl(
      {required this.trackingNumbers,
      required this.parcelNames,
      required this.customerType});

  @override
  final TrackingNumbers trackingNumbers;
  @override
  final ParcelNames parcelNames;
  @override
  final CustomerType customerType;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddParcelsState.customerTypeChanged(trackingNumbers: $trackingNumbers, parcelNames: $parcelNames, customerType: $customerType)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AddParcelsState.customerTypeChanged'))
      ..add(DiagnosticsProperty('trackingNumbers', trackingNumbers))
      ..add(DiagnosticsProperty('parcelNames', parcelNames))
      ..add(DiagnosticsProperty('customerType', customerType));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddParcelsStateCustomerTypeChangedImpl &&
            (identical(other.trackingNumbers, trackingNumbers) ||
                other.trackingNumbers == trackingNumbers) &&
            (identical(other.parcelNames, parcelNames) ||
                other.parcelNames == parcelNames) &&
            (identical(other.customerType, customerType) ||
                other.customerType == customerType));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, trackingNumbers, parcelNames, customerType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddParcelsStateCustomerTypeChangedImplCopyWith<
          _$AddParcelsStateCustomerTypeChangedImpl>
      get copyWith => __$$AddParcelsStateCustomerTypeChangedImplCopyWithImpl<
          _$AddParcelsStateCustomerTypeChangedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            TrackingNumbers trackingNumbers, ParcelNames parcelNames)
        initial,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        loaded,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        fieldChanged,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        customerTypeChanged,
    required TResult Function() adding,
    required TResult Function(List<TrackNumberInfo> addedTrackInfoList) added,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        validationFailed,
    required TResult Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)
        addFailed,
  }) {
    return customerTypeChanged(trackingNumbers, parcelNames, customerType);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames)?
        initial,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        loaded,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        fieldChanged,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        customerTypeChanged,
    TResult? Function()? adding,
    TResult? Function(List<TrackNumberInfo> addedTrackInfoList)? added,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        validationFailed,
    TResult? Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)?
        addFailed,
  }) {
    return customerTypeChanged?.call(
        trackingNumbers, parcelNames, customerType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames)?
        initial,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        loaded,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        fieldChanged,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        customerTypeChanged,
    TResult Function()? adding,
    TResult Function(List<TrackNumberInfo> addedTrackInfoList)? added,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        validationFailed,
    TResult Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)?
        addFailed,
    required TResult orElse(),
  }) {
    if (customerTypeChanged != null) {
      return customerTypeChanged(trackingNumbers, parcelNames, customerType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddParcelsStateInitial value) initial,
    required TResult Function(AddParcelsStateLoaded value) loaded,
    required TResult Function(AddParcelsStateFieldChanged value) fieldChanged,
    required TResult Function(AddParcelsStateCustomerTypeChanged value)
        customerTypeChanged,
    required TResult Function(AddParcelsStateAdding value) adding,
    required TResult Function(AddParcelsStateAdded value) added,
    required TResult Function(AddParcelsStateValidationFailed value)
        validationFailed,
    required TResult Function(AddParcelsStateAddFailed value) addFailed,
  }) {
    return customerTypeChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddParcelsStateInitial value)? initial,
    TResult? Function(AddParcelsStateLoaded value)? loaded,
    TResult? Function(AddParcelsStateFieldChanged value)? fieldChanged,
    TResult? Function(AddParcelsStateCustomerTypeChanged value)?
        customerTypeChanged,
    TResult? Function(AddParcelsStateAdding value)? adding,
    TResult? Function(AddParcelsStateAdded value)? added,
    TResult? Function(AddParcelsStateValidationFailed value)? validationFailed,
    TResult? Function(AddParcelsStateAddFailed value)? addFailed,
  }) {
    return customerTypeChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddParcelsStateInitial value)? initial,
    TResult Function(AddParcelsStateLoaded value)? loaded,
    TResult Function(AddParcelsStateFieldChanged value)? fieldChanged,
    TResult Function(AddParcelsStateCustomerTypeChanged value)?
        customerTypeChanged,
    TResult Function(AddParcelsStateAdding value)? adding,
    TResult Function(AddParcelsStateAdded value)? added,
    TResult Function(AddParcelsStateValidationFailed value)? validationFailed,
    TResult Function(AddParcelsStateAddFailed value)? addFailed,
    required TResult orElse(),
  }) {
    if (customerTypeChanged != null) {
      return customerTypeChanged(this);
    }
    return orElse();
  }
}

abstract class AddParcelsStateCustomerTypeChanged implements AddParcelsState {
  const factory AddParcelsStateCustomerTypeChanged(
          {required final TrackingNumbers trackingNumbers,
          required final ParcelNames parcelNames,
          required final CustomerType customerType}) =
      _$AddParcelsStateCustomerTypeChangedImpl;

  TrackingNumbers get trackingNumbers;
  ParcelNames get parcelNames;
  CustomerType get customerType;
  @JsonKey(ignore: true)
  _$$AddParcelsStateCustomerTypeChangedImplCopyWith<
          _$AddParcelsStateCustomerTypeChangedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddParcelsStateAddingImplCopyWith<$Res> {
  factory _$$AddParcelsStateAddingImplCopyWith(
          _$AddParcelsStateAddingImpl value,
          $Res Function(_$AddParcelsStateAddingImpl) then) =
      __$$AddParcelsStateAddingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AddParcelsStateAddingImplCopyWithImpl<$Res>
    extends _$AddParcelsStateCopyWithImpl<$Res, _$AddParcelsStateAddingImpl>
    implements _$$AddParcelsStateAddingImplCopyWith<$Res> {
  __$$AddParcelsStateAddingImplCopyWithImpl(_$AddParcelsStateAddingImpl _value,
      $Res Function(_$AddParcelsStateAddingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AddParcelsStateAddingImpl
    with DiagnosticableTreeMixin
    implements AddParcelsStateAdding {
  const _$AddParcelsStateAddingImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddParcelsState.adding()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'AddParcelsState.adding'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddParcelsStateAddingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            TrackingNumbers trackingNumbers, ParcelNames parcelNames)
        initial,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        loaded,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        fieldChanged,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        customerTypeChanged,
    required TResult Function() adding,
    required TResult Function(List<TrackNumberInfo> addedTrackInfoList) added,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        validationFailed,
    required TResult Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)
        addFailed,
  }) {
    return adding();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames)?
        initial,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        loaded,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        fieldChanged,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        customerTypeChanged,
    TResult? Function()? adding,
    TResult? Function(List<TrackNumberInfo> addedTrackInfoList)? added,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        validationFailed,
    TResult? Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)?
        addFailed,
  }) {
    return adding?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames)?
        initial,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        loaded,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        fieldChanged,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        customerTypeChanged,
    TResult Function()? adding,
    TResult Function(List<TrackNumberInfo> addedTrackInfoList)? added,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        validationFailed,
    TResult Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)?
        addFailed,
    required TResult orElse(),
  }) {
    if (adding != null) {
      return adding();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddParcelsStateInitial value) initial,
    required TResult Function(AddParcelsStateLoaded value) loaded,
    required TResult Function(AddParcelsStateFieldChanged value) fieldChanged,
    required TResult Function(AddParcelsStateCustomerTypeChanged value)
        customerTypeChanged,
    required TResult Function(AddParcelsStateAdding value) adding,
    required TResult Function(AddParcelsStateAdded value) added,
    required TResult Function(AddParcelsStateValidationFailed value)
        validationFailed,
    required TResult Function(AddParcelsStateAddFailed value) addFailed,
  }) {
    return adding(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddParcelsStateInitial value)? initial,
    TResult? Function(AddParcelsStateLoaded value)? loaded,
    TResult? Function(AddParcelsStateFieldChanged value)? fieldChanged,
    TResult? Function(AddParcelsStateCustomerTypeChanged value)?
        customerTypeChanged,
    TResult? Function(AddParcelsStateAdding value)? adding,
    TResult? Function(AddParcelsStateAdded value)? added,
    TResult? Function(AddParcelsStateValidationFailed value)? validationFailed,
    TResult? Function(AddParcelsStateAddFailed value)? addFailed,
  }) {
    return adding?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddParcelsStateInitial value)? initial,
    TResult Function(AddParcelsStateLoaded value)? loaded,
    TResult Function(AddParcelsStateFieldChanged value)? fieldChanged,
    TResult Function(AddParcelsStateCustomerTypeChanged value)?
        customerTypeChanged,
    TResult Function(AddParcelsStateAdding value)? adding,
    TResult Function(AddParcelsStateAdded value)? added,
    TResult Function(AddParcelsStateValidationFailed value)? validationFailed,
    TResult Function(AddParcelsStateAddFailed value)? addFailed,
    required TResult orElse(),
  }) {
    if (adding != null) {
      return adding(this);
    }
    return orElse();
  }
}

abstract class AddParcelsStateAdding implements AddParcelsState {
  const factory AddParcelsStateAdding() = _$AddParcelsStateAddingImpl;
}

/// @nodoc
abstract class _$$AddParcelsStateAddedImplCopyWith<$Res> {
  factory _$$AddParcelsStateAddedImplCopyWith(_$AddParcelsStateAddedImpl value,
          $Res Function(_$AddParcelsStateAddedImpl) then) =
      __$$AddParcelsStateAddedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<TrackNumberInfo> addedTrackInfoList});
}

/// @nodoc
class __$$AddParcelsStateAddedImplCopyWithImpl<$Res>
    extends _$AddParcelsStateCopyWithImpl<$Res, _$AddParcelsStateAddedImpl>
    implements _$$AddParcelsStateAddedImplCopyWith<$Res> {
  __$$AddParcelsStateAddedImplCopyWithImpl(_$AddParcelsStateAddedImpl _value,
      $Res Function(_$AddParcelsStateAddedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? addedTrackInfoList = null,
  }) {
    return _then(_$AddParcelsStateAddedImpl(
      addedTrackInfoList: null == addedTrackInfoList
          ? _value._addedTrackInfoList
          : addedTrackInfoList // ignore: cast_nullable_to_non_nullable
              as List<TrackNumberInfo>,
    ));
  }
}

/// @nodoc

class _$AddParcelsStateAddedImpl
    with DiagnosticableTreeMixin
    implements AddParcelsStateAdded {
  const _$AddParcelsStateAddedImpl(
      {required final List<TrackNumberInfo> addedTrackInfoList})
      : _addedTrackInfoList = addedTrackInfoList;

  final List<TrackNumberInfo> _addedTrackInfoList;
  @override
  List<TrackNumberInfo> get addedTrackInfoList {
    if (_addedTrackInfoList is EqualUnmodifiableListView)
      return _addedTrackInfoList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_addedTrackInfoList);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddParcelsState.added(addedTrackInfoList: $addedTrackInfoList)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AddParcelsState.added'))
      ..add(DiagnosticsProperty('addedTrackInfoList', addedTrackInfoList));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddParcelsStateAddedImpl &&
            const DeepCollectionEquality()
                .equals(other._addedTrackInfoList, _addedTrackInfoList));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_addedTrackInfoList));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddParcelsStateAddedImplCopyWith<_$AddParcelsStateAddedImpl>
      get copyWith =>
          __$$AddParcelsStateAddedImplCopyWithImpl<_$AddParcelsStateAddedImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            TrackingNumbers trackingNumbers, ParcelNames parcelNames)
        initial,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        loaded,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        fieldChanged,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        customerTypeChanged,
    required TResult Function() adding,
    required TResult Function(List<TrackNumberInfo> addedTrackInfoList) added,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        validationFailed,
    required TResult Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)
        addFailed,
  }) {
    return added(addedTrackInfoList);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames)?
        initial,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        loaded,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        fieldChanged,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        customerTypeChanged,
    TResult? Function()? adding,
    TResult? Function(List<TrackNumberInfo> addedTrackInfoList)? added,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        validationFailed,
    TResult? Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)?
        addFailed,
  }) {
    return added?.call(addedTrackInfoList);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames)?
        initial,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        loaded,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        fieldChanged,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        customerTypeChanged,
    TResult Function()? adding,
    TResult Function(List<TrackNumberInfo> addedTrackInfoList)? added,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        validationFailed,
    TResult Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)?
        addFailed,
    required TResult orElse(),
  }) {
    if (added != null) {
      return added(addedTrackInfoList);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddParcelsStateInitial value) initial,
    required TResult Function(AddParcelsStateLoaded value) loaded,
    required TResult Function(AddParcelsStateFieldChanged value) fieldChanged,
    required TResult Function(AddParcelsStateCustomerTypeChanged value)
        customerTypeChanged,
    required TResult Function(AddParcelsStateAdding value) adding,
    required TResult Function(AddParcelsStateAdded value) added,
    required TResult Function(AddParcelsStateValidationFailed value)
        validationFailed,
    required TResult Function(AddParcelsStateAddFailed value) addFailed,
  }) {
    return added(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddParcelsStateInitial value)? initial,
    TResult? Function(AddParcelsStateLoaded value)? loaded,
    TResult? Function(AddParcelsStateFieldChanged value)? fieldChanged,
    TResult? Function(AddParcelsStateCustomerTypeChanged value)?
        customerTypeChanged,
    TResult? Function(AddParcelsStateAdding value)? adding,
    TResult? Function(AddParcelsStateAdded value)? added,
    TResult? Function(AddParcelsStateValidationFailed value)? validationFailed,
    TResult? Function(AddParcelsStateAddFailed value)? addFailed,
  }) {
    return added?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddParcelsStateInitial value)? initial,
    TResult Function(AddParcelsStateLoaded value)? loaded,
    TResult Function(AddParcelsStateFieldChanged value)? fieldChanged,
    TResult Function(AddParcelsStateCustomerTypeChanged value)?
        customerTypeChanged,
    TResult Function(AddParcelsStateAdding value)? adding,
    TResult Function(AddParcelsStateAdded value)? added,
    TResult Function(AddParcelsStateValidationFailed value)? validationFailed,
    TResult Function(AddParcelsStateAddFailed value)? addFailed,
    required TResult orElse(),
  }) {
    if (added != null) {
      return added(this);
    }
    return orElse();
  }
}

abstract class AddParcelsStateAdded implements AddParcelsState {
  const factory AddParcelsStateAdded(
          {required final List<TrackNumberInfo> addedTrackInfoList}) =
      _$AddParcelsStateAddedImpl;

  List<TrackNumberInfo> get addedTrackInfoList;
  @JsonKey(ignore: true)
  _$$AddParcelsStateAddedImplCopyWith<_$AddParcelsStateAddedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddParcelsStateValidationFailedImplCopyWith<$Res> {
  factory _$$AddParcelsStateValidationFailedImplCopyWith(
          _$AddParcelsStateValidationFailedImpl value,
          $Res Function(_$AddParcelsStateValidationFailedImpl) then) =
      __$$AddParcelsStateValidationFailedImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {TrackingNumbers trackingNumbers,
      ParcelNames parcelNames,
      CustomerType customerType});

  $TrackingNumbersCopyWith<$Res> get trackingNumbers;
  $ParcelNamesCopyWith<$Res> get parcelNames;
}

/// @nodoc
class __$$AddParcelsStateValidationFailedImplCopyWithImpl<$Res>
    extends _$AddParcelsStateCopyWithImpl<$Res,
        _$AddParcelsStateValidationFailedImpl>
    implements _$$AddParcelsStateValidationFailedImplCopyWith<$Res> {
  __$$AddParcelsStateValidationFailedImplCopyWithImpl(
      _$AddParcelsStateValidationFailedImpl _value,
      $Res Function(_$AddParcelsStateValidationFailedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? trackingNumbers = null,
    Object? parcelNames = null,
    Object? customerType = null,
  }) {
    return _then(_$AddParcelsStateValidationFailedImpl(
      trackingNumbers: null == trackingNumbers
          ? _value.trackingNumbers
          : trackingNumbers // ignore: cast_nullable_to_non_nullable
              as TrackingNumbers,
      parcelNames: null == parcelNames
          ? _value.parcelNames
          : parcelNames // ignore: cast_nullable_to_non_nullable
              as ParcelNames,
      customerType: null == customerType
          ? _value.customerType
          : customerType // ignore: cast_nullable_to_non_nullable
              as CustomerType,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $TrackingNumbersCopyWith<$Res> get trackingNumbers {
    return $TrackingNumbersCopyWith<$Res>(_value.trackingNumbers, (value) {
      return _then(_value.copyWith(trackingNumbers: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ParcelNamesCopyWith<$Res> get parcelNames {
    return $ParcelNamesCopyWith<$Res>(_value.parcelNames, (value) {
      return _then(_value.copyWith(parcelNames: value));
    });
  }
}

/// @nodoc

class _$AddParcelsStateValidationFailedImpl
    with DiagnosticableTreeMixin
    implements AddParcelsStateValidationFailed {
  const _$AddParcelsStateValidationFailedImpl(
      {required this.trackingNumbers,
      required this.parcelNames,
      required this.customerType});

  @override
  final TrackingNumbers trackingNumbers;
  @override
  final ParcelNames parcelNames;
  @override
  final CustomerType customerType;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddParcelsState.validationFailed(trackingNumbers: $trackingNumbers, parcelNames: $parcelNames, customerType: $customerType)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AddParcelsState.validationFailed'))
      ..add(DiagnosticsProperty('trackingNumbers', trackingNumbers))
      ..add(DiagnosticsProperty('parcelNames', parcelNames))
      ..add(DiagnosticsProperty('customerType', customerType));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddParcelsStateValidationFailedImpl &&
            (identical(other.trackingNumbers, trackingNumbers) ||
                other.trackingNumbers == trackingNumbers) &&
            (identical(other.parcelNames, parcelNames) ||
                other.parcelNames == parcelNames) &&
            (identical(other.customerType, customerType) ||
                other.customerType == customerType));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, trackingNumbers, parcelNames, customerType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddParcelsStateValidationFailedImplCopyWith<
          _$AddParcelsStateValidationFailedImpl>
      get copyWith => __$$AddParcelsStateValidationFailedImplCopyWithImpl<
          _$AddParcelsStateValidationFailedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            TrackingNumbers trackingNumbers, ParcelNames parcelNames)
        initial,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        loaded,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        fieldChanged,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        customerTypeChanged,
    required TResult Function() adding,
    required TResult Function(List<TrackNumberInfo> addedTrackInfoList) added,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        validationFailed,
    required TResult Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)
        addFailed,
  }) {
    return validationFailed(trackingNumbers, parcelNames, customerType);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames)?
        initial,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        loaded,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        fieldChanged,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        customerTypeChanged,
    TResult? Function()? adding,
    TResult? Function(List<TrackNumberInfo> addedTrackInfoList)? added,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        validationFailed,
    TResult? Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)?
        addFailed,
  }) {
    return validationFailed?.call(trackingNumbers, parcelNames, customerType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames)?
        initial,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        loaded,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        fieldChanged,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        customerTypeChanged,
    TResult Function()? adding,
    TResult Function(List<TrackNumberInfo> addedTrackInfoList)? added,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        validationFailed,
    TResult Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)?
        addFailed,
    required TResult orElse(),
  }) {
    if (validationFailed != null) {
      return validationFailed(trackingNumbers, parcelNames, customerType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddParcelsStateInitial value) initial,
    required TResult Function(AddParcelsStateLoaded value) loaded,
    required TResult Function(AddParcelsStateFieldChanged value) fieldChanged,
    required TResult Function(AddParcelsStateCustomerTypeChanged value)
        customerTypeChanged,
    required TResult Function(AddParcelsStateAdding value) adding,
    required TResult Function(AddParcelsStateAdded value) added,
    required TResult Function(AddParcelsStateValidationFailed value)
        validationFailed,
    required TResult Function(AddParcelsStateAddFailed value) addFailed,
  }) {
    return validationFailed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddParcelsStateInitial value)? initial,
    TResult? Function(AddParcelsStateLoaded value)? loaded,
    TResult? Function(AddParcelsStateFieldChanged value)? fieldChanged,
    TResult? Function(AddParcelsStateCustomerTypeChanged value)?
        customerTypeChanged,
    TResult? Function(AddParcelsStateAdding value)? adding,
    TResult? Function(AddParcelsStateAdded value)? added,
    TResult? Function(AddParcelsStateValidationFailed value)? validationFailed,
    TResult? Function(AddParcelsStateAddFailed value)? addFailed,
  }) {
    return validationFailed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddParcelsStateInitial value)? initial,
    TResult Function(AddParcelsStateLoaded value)? loaded,
    TResult Function(AddParcelsStateFieldChanged value)? fieldChanged,
    TResult Function(AddParcelsStateCustomerTypeChanged value)?
        customerTypeChanged,
    TResult Function(AddParcelsStateAdding value)? adding,
    TResult Function(AddParcelsStateAdded value)? added,
    TResult Function(AddParcelsStateValidationFailed value)? validationFailed,
    TResult Function(AddParcelsStateAddFailed value)? addFailed,
    required TResult orElse(),
  }) {
    if (validationFailed != null) {
      return validationFailed(this);
    }
    return orElse();
  }
}

abstract class AddParcelsStateValidationFailed implements AddParcelsState {
  const factory AddParcelsStateValidationFailed(
          {required final TrackingNumbers trackingNumbers,
          required final ParcelNames parcelNames,
          required final CustomerType customerType}) =
      _$AddParcelsStateValidationFailedImpl;

  TrackingNumbers get trackingNumbers;
  ParcelNames get parcelNames;
  CustomerType get customerType;
  @JsonKey(ignore: true)
  _$$AddParcelsStateValidationFailedImplCopyWith<
          _$AddParcelsStateValidationFailedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddParcelsStateAddFailedImplCopyWith<$Res> {
  factory _$$AddParcelsStateAddFailedImplCopyWith(
          _$AddParcelsStateAddFailedImpl value,
          $Res Function(_$AddParcelsStateAddFailedImpl) then) =
      __$$AddParcelsStateAddFailedImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {TrackingNumbers trackingNumbers,
      ParcelNames parcelNames,
      CustomerType customerType,
      Exception? exception,
      StackTrace? stackTrace});

  $TrackingNumbersCopyWith<$Res> get trackingNumbers;
  $ParcelNamesCopyWith<$Res> get parcelNames;
}

/// @nodoc
class __$$AddParcelsStateAddFailedImplCopyWithImpl<$Res>
    extends _$AddParcelsStateCopyWithImpl<$Res, _$AddParcelsStateAddFailedImpl>
    implements _$$AddParcelsStateAddFailedImplCopyWith<$Res> {
  __$$AddParcelsStateAddFailedImplCopyWithImpl(
      _$AddParcelsStateAddFailedImpl _value,
      $Res Function(_$AddParcelsStateAddFailedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? trackingNumbers = null,
    Object? parcelNames = null,
    Object? customerType = null,
    Object? exception = freezed,
    Object? stackTrace = freezed,
  }) {
    return _then(_$AddParcelsStateAddFailedImpl(
      trackingNumbers: null == trackingNumbers
          ? _value.trackingNumbers
          : trackingNumbers // ignore: cast_nullable_to_non_nullable
              as TrackingNumbers,
      parcelNames: null == parcelNames
          ? _value.parcelNames
          : parcelNames // ignore: cast_nullable_to_non_nullable
              as ParcelNames,
      customerType: null == customerType
          ? _value.customerType
          : customerType // ignore: cast_nullable_to_non_nullable
              as CustomerType,
      exception: freezed == exception
          ? _value.exception
          : exception // ignore: cast_nullable_to_non_nullable
              as Exception?,
      stackTrace: freezed == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $TrackingNumbersCopyWith<$Res> get trackingNumbers {
    return $TrackingNumbersCopyWith<$Res>(_value.trackingNumbers, (value) {
      return _then(_value.copyWith(trackingNumbers: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ParcelNamesCopyWith<$Res> get parcelNames {
    return $ParcelNamesCopyWith<$Res>(_value.parcelNames, (value) {
      return _then(_value.copyWith(parcelNames: value));
    });
  }
}

/// @nodoc

class _$AddParcelsStateAddFailedImpl
    with DiagnosticableTreeMixin
    implements AddParcelsStateAddFailed {
  const _$AddParcelsStateAddFailedImpl(
      {required this.trackingNumbers,
      required this.parcelNames,
      required this.customerType,
      this.exception,
      this.stackTrace});

  @override
  final TrackingNumbers trackingNumbers;
  @override
  final ParcelNames parcelNames;
  @override
  final CustomerType customerType;
  @override
  final Exception? exception;
  @override
  final StackTrace? stackTrace;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddParcelsState.addFailed(trackingNumbers: $trackingNumbers, parcelNames: $parcelNames, customerType: $customerType, exception: $exception, stackTrace: $stackTrace)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AddParcelsState.addFailed'))
      ..add(DiagnosticsProperty('trackingNumbers', trackingNumbers))
      ..add(DiagnosticsProperty('parcelNames', parcelNames))
      ..add(DiagnosticsProperty('customerType', customerType))
      ..add(DiagnosticsProperty('exception', exception))
      ..add(DiagnosticsProperty('stackTrace', stackTrace));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddParcelsStateAddFailedImpl &&
            (identical(other.trackingNumbers, trackingNumbers) ||
                other.trackingNumbers == trackingNumbers) &&
            (identical(other.parcelNames, parcelNames) ||
                other.parcelNames == parcelNames) &&
            (identical(other.customerType, customerType) ||
                other.customerType == customerType) &&
            (identical(other.exception, exception) ||
                other.exception == exception) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace));
  }

  @override
  int get hashCode => Object.hash(runtimeType, trackingNumbers, parcelNames,
      customerType, exception, stackTrace);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddParcelsStateAddFailedImplCopyWith<_$AddParcelsStateAddFailedImpl>
      get copyWith => __$$AddParcelsStateAddFailedImplCopyWithImpl<
          _$AddParcelsStateAddFailedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            TrackingNumbers trackingNumbers, ParcelNames parcelNames)
        initial,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        loaded,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        fieldChanged,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        customerTypeChanged,
    required TResult Function() adding,
    required TResult Function(List<TrackNumberInfo> addedTrackInfoList) added,
    required TResult Function(TrackingNumbers trackingNumbers,
            ParcelNames parcelNames, CustomerType customerType)
        validationFailed,
    required TResult Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)
        addFailed,
  }) {
    return addFailed(
        trackingNumbers, parcelNames, customerType, exception, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames)?
        initial,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        loaded,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        fieldChanged,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        customerTypeChanged,
    TResult? Function()? adding,
    TResult? Function(List<TrackNumberInfo> addedTrackInfoList)? added,
    TResult? Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        validationFailed,
    TResult? Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)?
        addFailed,
  }) {
    return addFailed?.call(
        trackingNumbers, parcelNames, customerType, exception, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames)?
        initial,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        loaded,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        fieldChanged,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        customerTypeChanged,
    TResult Function()? adding,
    TResult Function(List<TrackNumberInfo> addedTrackInfoList)? added,
    TResult Function(TrackingNumbers trackingNumbers, ParcelNames parcelNames,
            CustomerType customerType)?
        validationFailed,
    TResult Function(
            TrackingNumbers trackingNumbers,
            ParcelNames parcelNames,
            CustomerType customerType,
            Exception? exception,
            StackTrace? stackTrace)?
        addFailed,
    required TResult orElse(),
  }) {
    if (addFailed != null) {
      return addFailed(
          trackingNumbers, parcelNames, customerType, exception, stackTrace);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddParcelsStateInitial value) initial,
    required TResult Function(AddParcelsStateLoaded value) loaded,
    required TResult Function(AddParcelsStateFieldChanged value) fieldChanged,
    required TResult Function(AddParcelsStateCustomerTypeChanged value)
        customerTypeChanged,
    required TResult Function(AddParcelsStateAdding value) adding,
    required TResult Function(AddParcelsStateAdded value) added,
    required TResult Function(AddParcelsStateValidationFailed value)
        validationFailed,
    required TResult Function(AddParcelsStateAddFailed value) addFailed,
  }) {
    return addFailed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddParcelsStateInitial value)? initial,
    TResult? Function(AddParcelsStateLoaded value)? loaded,
    TResult? Function(AddParcelsStateFieldChanged value)? fieldChanged,
    TResult? Function(AddParcelsStateCustomerTypeChanged value)?
        customerTypeChanged,
    TResult? Function(AddParcelsStateAdding value)? adding,
    TResult? Function(AddParcelsStateAdded value)? added,
    TResult? Function(AddParcelsStateValidationFailed value)? validationFailed,
    TResult? Function(AddParcelsStateAddFailed value)? addFailed,
  }) {
    return addFailed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddParcelsStateInitial value)? initial,
    TResult Function(AddParcelsStateLoaded value)? loaded,
    TResult Function(AddParcelsStateFieldChanged value)? fieldChanged,
    TResult Function(AddParcelsStateCustomerTypeChanged value)?
        customerTypeChanged,
    TResult Function(AddParcelsStateAdding value)? adding,
    TResult Function(AddParcelsStateAdded value)? added,
    TResult Function(AddParcelsStateValidationFailed value)? validationFailed,
    TResult Function(AddParcelsStateAddFailed value)? addFailed,
    required TResult orElse(),
  }) {
    if (addFailed != null) {
      return addFailed(this);
    }
    return orElse();
  }
}

abstract class AddParcelsStateAddFailed implements AddParcelsState {
  const factory AddParcelsStateAddFailed(
      {required final TrackingNumbers trackingNumbers,
      required final ParcelNames parcelNames,
      required final CustomerType customerType,
      final Exception? exception,
      final StackTrace? stackTrace}) = _$AddParcelsStateAddFailedImpl;

  TrackingNumbers get trackingNumbers;
  ParcelNames get parcelNames;
  CustomerType get customerType;
  Exception? get exception;
  StackTrace? get stackTrace;
  @JsonKey(ignore: true)
  _$$AddParcelsStateAddFailedImplCopyWith<_$AddParcelsStateAddFailedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$TrackingNumbers {
  String get value => throw _privateConstructorUsedError;
  TrackingNumbersError? get error => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $TrackingNumbersCopyWith<TrackingNumbers> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TrackingNumbersCopyWith<$Res> {
  factory $TrackingNumbersCopyWith(
          TrackingNumbers value, $Res Function(TrackingNumbers) then) =
      _$TrackingNumbersCopyWithImpl<$Res, TrackingNumbers>;
  @useResult
  $Res call({String value, TrackingNumbersError? error});

  $TrackingNumbersErrorCopyWith<$Res>? get error;
}

/// @nodoc
class _$TrackingNumbersCopyWithImpl<$Res, $Val extends TrackingNumbers>
    implements $TrackingNumbersCopyWith<$Res> {
  _$TrackingNumbersCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
    Object? error = freezed,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as TrackingNumbersError?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $TrackingNumbersErrorCopyWith<$Res>? get error {
    if (_value.error == null) {
      return null;
    }

    return $TrackingNumbersErrorCopyWith<$Res>(_value.error!, (value) {
      return _then(_value.copyWith(error: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$TrackingNumbersImplCopyWith<$Res>
    implements $TrackingNumbersCopyWith<$Res> {
  factory _$$TrackingNumbersImplCopyWith(_$TrackingNumbersImpl value,
          $Res Function(_$TrackingNumbersImpl) then) =
      __$$TrackingNumbersImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String value, TrackingNumbersError? error});

  @override
  $TrackingNumbersErrorCopyWith<$Res>? get error;
}

/// @nodoc
class __$$TrackingNumbersImplCopyWithImpl<$Res>
    extends _$TrackingNumbersCopyWithImpl<$Res, _$TrackingNumbersImpl>
    implements _$$TrackingNumbersImplCopyWith<$Res> {
  __$$TrackingNumbersImplCopyWithImpl(
      _$TrackingNumbersImpl _value, $Res Function(_$TrackingNumbersImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
    Object? error = freezed,
  }) {
    return _then(_$TrackingNumbersImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as TrackingNumbersError?,
    ));
  }
}

/// @nodoc

class _$TrackingNumbersImpl
    with DiagnosticableTreeMixin
    implements _TrackingNumbers {
  const _$TrackingNumbersImpl({this.value = '', this.error});

  @override
  @JsonKey()
  final String value;
  @override
  final TrackingNumbersError? error;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TrackingNumbers(value: $value, error: $error)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TrackingNumbers'))
      ..add(DiagnosticsProperty('value', value))
      ..add(DiagnosticsProperty('error', error));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TrackingNumbersImpl &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TrackingNumbersImplCopyWith<_$TrackingNumbersImpl> get copyWith =>
      __$$TrackingNumbersImplCopyWithImpl<_$TrackingNumbersImpl>(
          this, _$identity);
}

abstract class _TrackingNumbers implements TrackingNumbers {
  const factory _TrackingNumbers(
      {final String value,
      final TrackingNumbersError? error}) = _$TrackingNumbersImpl;

  @override
  String get value;
  @override
  TrackingNumbersError? get error;
  @override
  @JsonKey(ignore: true)
  _$$TrackingNumbersImplCopyWith<_$TrackingNumbersImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$TrackingNumbersError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TrackingNumbersErrorEmpty value) empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TrackingNumbersErrorEmpty value)? empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TrackingNumbersErrorEmpty value)? empty,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TrackingNumbersErrorCopyWith<$Res> {
  factory $TrackingNumbersErrorCopyWith(TrackingNumbersError value,
          $Res Function(TrackingNumbersError) then) =
      _$TrackingNumbersErrorCopyWithImpl<$Res, TrackingNumbersError>;
}

/// @nodoc
class _$TrackingNumbersErrorCopyWithImpl<$Res,
        $Val extends TrackingNumbersError>
    implements $TrackingNumbersErrorCopyWith<$Res> {
  _$TrackingNumbersErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$TrackingNumbersErrorEmptyImplCopyWith<$Res> {
  factory _$$TrackingNumbersErrorEmptyImplCopyWith(
          _$TrackingNumbersErrorEmptyImpl value,
          $Res Function(_$TrackingNumbersErrorEmptyImpl) then) =
      __$$TrackingNumbersErrorEmptyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TrackingNumbersErrorEmptyImplCopyWithImpl<$Res>
    extends _$TrackingNumbersErrorCopyWithImpl<$Res,
        _$TrackingNumbersErrorEmptyImpl>
    implements _$$TrackingNumbersErrorEmptyImplCopyWith<$Res> {
  __$$TrackingNumbersErrorEmptyImplCopyWithImpl(
      _$TrackingNumbersErrorEmptyImpl _value,
      $Res Function(_$TrackingNumbersErrorEmptyImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TrackingNumbersErrorEmptyImpl
    with DiagnosticableTreeMixin
    implements TrackingNumbersErrorEmpty {
  const _$TrackingNumbersErrorEmptyImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TrackingNumbersError.empty()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'TrackingNumbersError.empty'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TrackingNumbersErrorEmptyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TrackingNumbersErrorEmpty value) empty,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TrackingNumbersErrorEmpty value)? empty,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TrackingNumbersErrorEmpty value)? empty,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class TrackingNumbersErrorEmpty implements TrackingNumbersError {
  const factory TrackingNumbersErrorEmpty() = _$TrackingNumbersErrorEmptyImpl;
}

/// @nodoc
mixin _$ParcelNames {
  String get value => throw _privateConstructorUsedError;
  ParcelNamesError? get error => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ParcelNamesCopyWith<ParcelNames> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ParcelNamesCopyWith<$Res> {
  factory $ParcelNamesCopyWith(
          ParcelNames value, $Res Function(ParcelNames) then) =
      _$ParcelNamesCopyWithImpl<$Res, ParcelNames>;
  @useResult
  $Res call({String value, ParcelNamesError? error});
}

/// @nodoc
class _$ParcelNamesCopyWithImpl<$Res, $Val extends ParcelNames>
    implements $ParcelNamesCopyWith<$Res> {
  _$ParcelNamesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
    Object? error = freezed,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as ParcelNamesError?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ParcelNamesImplCopyWith<$Res>
    implements $ParcelNamesCopyWith<$Res> {
  factory _$$ParcelNamesImplCopyWith(
          _$ParcelNamesImpl value, $Res Function(_$ParcelNamesImpl) then) =
      __$$ParcelNamesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String value, ParcelNamesError? error});
}

/// @nodoc
class __$$ParcelNamesImplCopyWithImpl<$Res>
    extends _$ParcelNamesCopyWithImpl<$Res, _$ParcelNamesImpl>
    implements _$$ParcelNamesImplCopyWith<$Res> {
  __$$ParcelNamesImplCopyWithImpl(
      _$ParcelNamesImpl _value, $Res Function(_$ParcelNamesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
    Object? error = freezed,
  }) {
    return _then(_$ParcelNamesImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as ParcelNamesError?,
    ));
  }
}

/// @nodoc

class _$ParcelNamesImpl with DiagnosticableTreeMixin implements _ParcelNames {
  const _$ParcelNamesImpl({this.value = '', this.error});

  @override
  @JsonKey()
  final String value;
  @override
  final ParcelNamesError? error;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ParcelNames(value: $value, error: $error)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ParcelNames'))
      ..add(DiagnosticsProperty('value', value))
      ..add(DiagnosticsProperty('error', error));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ParcelNamesImpl &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ParcelNamesImplCopyWith<_$ParcelNamesImpl> get copyWith =>
      __$$ParcelNamesImplCopyWithImpl<_$ParcelNamesImpl>(this, _$identity);
}

abstract class _ParcelNames implements ParcelNames {
  const factory _ParcelNames(
      {final String value, final ParcelNamesError? error}) = _$ParcelNamesImpl;

  @override
  String get value;
  @override
  ParcelNamesError? get error;
  @override
  @JsonKey(ignore: true)
  _$$ParcelNamesImplCopyWith<_$ParcelNamesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$TrackingNumbersParseResult {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> trackList) success,
    required TResult Function(TrackingNumbersError reason) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> trackList)? success,
    TResult? Function(TrackingNumbersError reason)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> trackList)? success,
    TResult Function(TrackingNumbersError reason)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TrackingNumbersParseResultSuccess value) success,
    required TResult Function(TrackingNumbersParseResultError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TrackingNumbersParseResultSuccess value)? success,
    TResult? Function(TrackingNumbersParseResultError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TrackingNumbersParseResultSuccess value)? success,
    TResult Function(TrackingNumbersParseResultError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TrackingNumbersParseResultCopyWith<$Res> {
  factory $TrackingNumbersParseResultCopyWith(TrackingNumbersParseResult value,
          $Res Function(TrackingNumbersParseResult) then) =
      _$TrackingNumbersParseResultCopyWithImpl<$Res,
          TrackingNumbersParseResult>;
}

/// @nodoc
class _$TrackingNumbersParseResultCopyWithImpl<$Res,
        $Val extends TrackingNumbersParseResult>
    implements $TrackingNumbersParseResultCopyWith<$Res> {
  _$TrackingNumbersParseResultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$TrackingNumbersParseResultSuccessImplCopyWith<$Res> {
  factory _$$TrackingNumbersParseResultSuccessImplCopyWith(
          _$TrackingNumbersParseResultSuccessImpl value,
          $Res Function(_$TrackingNumbersParseResultSuccessImpl) then) =
      __$$TrackingNumbersParseResultSuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> trackList});
}

/// @nodoc
class __$$TrackingNumbersParseResultSuccessImplCopyWithImpl<$Res>
    extends _$TrackingNumbersParseResultCopyWithImpl<$Res,
        _$TrackingNumbersParseResultSuccessImpl>
    implements _$$TrackingNumbersParseResultSuccessImplCopyWith<$Res> {
  __$$TrackingNumbersParseResultSuccessImplCopyWithImpl(
      _$TrackingNumbersParseResultSuccessImpl _value,
      $Res Function(_$TrackingNumbersParseResultSuccessImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? trackList = null,
  }) {
    return _then(_$TrackingNumbersParseResultSuccessImpl(
      trackList: null == trackList
          ? _value._trackList
          : trackList // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$TrackingNumbersParseResultSuccessImpl
    with DiagnosticableTreeMixin
    implements TrackingNumbersParseResultSuccess {
  const _$TrackingNumbersParseResultSuccessImpl(
      {required final List<String> trackList})
      : _trackList = trackList;

  final List<String> _trackList;
  @override
  List<String> get trackList {
    if (_trackList is EqualUnmodifiableListView) return _trackList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_trackList);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TrackingNumbersParseResult.success(trackList: $trackList)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TrackingNumbersParseResult.success'))
      ..add(DiagnosticsProperty('trackList', trackList));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TrackingNumbersParseResultSuccessImpl &&
            const DeepCollectionEquality()
                .equals(other._trackList, _trackList));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_trackList));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TrackingNumbersParseResultSuccessImplCopyWith<
          _$TrackingNumbersParseResultSuccessImpl>
      get copyWith => __$$TrackingNumbersParseResultSuccessImplCopyWithImpl<
          _$TrackingNumbersParseResultSuccessImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> trackList) success,
    required TResult Function(TrackingNumbersError reason) error,
  }) {
    return success(trackList);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> trackList)? success,
    TResult? Function(TrackingNumbersError reason)? error,
  }) {
    return success?.call(trackList);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> trackList)? success,
    TResult Function(TrackingNumbersError reason)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(trackList);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TrackingNumbersParseResultSuccess value) success,
    required TResult Function(TrackingNumbersParseResultError value) error,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TrackingNumbersParseResultSuccess value)? success,
    TResult? Function(TrackingNumbersParseResultError value)? error,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TrackingNumbersParseResultSuccess value)? success,
    TResult Function(TrackingNumbersParseResultError value)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class TrackingNumbersParseResultSuccess
    implements TrackingNumbersParseResult {
  const factory TrackingNumbersParseResultSuccess(
          {required final List<String> trackList}) =
      _$TrackingNumbersParseResultSuccessImpl;

  List<String> get trackList;
  @JsonKey(ignore: true)
  _$$TrackingNumbersParseResultSuccessImplCopyWith<
          _$TrackingNumbersParseResultSuccessImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TrackingNumbersParseResultErrorImplCopyWith<$Res> {
  factory _$$TrackingNumbersParseResultErrorImplCopyWith(
          _$TrackingNumbersParseResultErrorImpl value,
          $Res Function(_$TrackingNumbersParseResultErrorImpl) then) =
      __$$TrackingNumbersParseResultErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({TrackingNumbersError reason});

  $TrackingNumbersErrorCopyWith<$Res> get reason;
}

/// @nodoc
class __$$TrackingNumbersParseResultErrorImplCopyWithImpl<$Res>
    extends _$TrackingNumbersParseResultCopyWithImpl<$Res,
        _$TrackingNumbersParseResultErrorImpl>
    implements _$$TrackingNumbersParseResultErrorImplCopyWith<$Res> {
  __$$TrackingNumbersParseResultErrorImplCopyWithImpl(
      _$TrackingNumbersParseResultErrorImpl _value,
      $Res Function(_$TrackingNumbersParseResultErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? reason = null,
  }) {
    return _then(_$TrackingNumbersParseResultErrorImpl(
      reason: null == reason
          ? _value.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as TrackingNumbersError,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $TrackingNumbersErrorCopyWith<$Res> get reason {
    return $TrackingNumbersErrorCopyWith<$Res>(_value.reason, (value) {
      return _then(_value.copyWith(reason: value));
    });
  }
}

/// @nodoc

class _$TrackingNumbersParseResultErrorImpl
    with DiagnosticableTreeMixin
    implements TrackingNumbersParseResultError {
  const _$TrackingNumbersParseResultErrorImpl({required this.reason});

  @override
  final TrackingNumbersError reason;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TrackingNumbersParseResult.error(reason: $reason)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TrackingNumbersParseResult.error'))
      ..add(DiagnosticsProperty('reason', reason));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TrackingNumbersParseResultErrorImpl &&
            (identical(other.reason, reason) || other.reason == reason));
  }

  @override
  int get hashCode => Object.hash(runtimeType, reason);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TrackingNumbersParseResultErrorImplCopyWith<
          _$TrackingNumbersParseResultErrorImpl>
      get copyWith => __$$TrackingNumbersParseResultErrorImplCopyWithImpl<
          _$TrackingNumbersParseResultErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> trackList) success,
    required TResult Function(TrackingNumbersError reason) error,
  }) {
    return error(reason);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> trackList)? success,
    TResult? Function(TrackingNumbersError reason)? error,
  }) {
    return error?.call(reason);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> trackList)? success,
    TResult Function(TrackingNumbersError reason)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(reason);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TrackingNumbersParseResultSuccess value) success,
    required TResult Function(TrackingNumbersParseResultError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TrackingNumbersParseResultSuccess value)? success,
    TResult? Function(TrackingNumbersParseResultError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TrackingNumbersParseResultSuccess value)? success,
    TResult Function(TrackingNumbersParseResultError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class TrackingNumbersParseResultError
    implements TrackingNumbersParseResult {
  const factory TrackingNumbersParseResultError(
          {required final TrackingNumbersError reason}) =
      _$TrackingNumbersParseResultErrorImpl;

  TrackingNumbersError get reason;
  @JsonKey(ignore: true)
  _$$TrackingNumbersParseResultErrorImplCopyWith<
          _$TrackingNumbersParseResultErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ParcelNamesParseResult {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> namesList) success,
    required TResult Function(ParcelNamesError reason) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> namesList)? success,
    TResult? Function(ParcelNamesError reason)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> namesList)? success,
    TResult Function(ParcelNamesError reason)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ParcelNamesParseResultSuccess value) success,
    required TResult Function(ParcelNamesParseResultError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ParcelNamesParseResultSuccess value)? success,
    TResult? Function(ParcelNamesParseResultError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ParcelNamesParseResultSuccess value)? success,
    TResult Function(ParcelNamesParseResultError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ParcelNamesParseResultCopyWith<$Res> {
  factory $ParcelNamesParseResultCopyWith(ParcelNamesParseResult value,
          $Res Function(ParcelNamesParseResult) then) =
      _$ParcelNamesParseResultCopyWithImpl<$Res, ParcelNamesParseResult>;
}

/// @nodoc
class _$ParcelNamesParseResultCopyWithImpl<$Res,
        $Val extends ParcelNamesParseResult>
    implements $ParcelNamesParseResultCopyWith<$Res> {
  _$ParcelNamesParseResultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ParcelNamesParseResultSuccessImplCopyWith<$Res> {
  factory _$$ParcelNamesParseResultSuccessImplCopyWith(
          _$ParcelNamesParseResultSuccessImpl value,
          $Res Function(_$ParcelNamesParseResultSuccessImpl) then) =
      __$$ParcelNamesParseResultSuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> namesList});
}

/// @nodoc
class __$$ParcelNamesParseResultSuccessImplCopyWithImpl<$Res>
    extends _$ParcelNamesParseResultCopyWithImpl<$Res,
        _$ParcelNamesParseResultSuccessImpl>
    implements _$$ParcelNamesParseResultSuccessImplCopyWith<$Res> {
  __$$ParcelNamesParseResultSuccessImplCopyWithImpl(
      _$ParcelNamesParseResultSuccessImpl _value,
      $Res Function(_$ParcelNamesParseResultSuccessImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? namesList = null,
  }) {
    return _then(_$ParcelNamesParseResultSuccessImpl(
      namesList: null == namesList
          ? _value._namesList
          : namesList // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$ParcelNamesParseResultSuccessImpl
    with DiagnosticableTreeMixin
    implements ParcelNamesParseResultSuccess {
  const _$ParcelNamesParseResultSuccessImpl(
      {required final List<String> namesList})
      : _namesList = namesList;

  final List<String> _namesList;
  @override
  List<String> get namesList {
    if (_namesList is EqualUnmodifiableListView) return _namesList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_namesList);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ParcelNamesParseResult.success(namesList: $namesList)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ParcelNamesParseResult.success'))
      ..add(DiagnosticsProperty('namesList', namesList));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ParcelNamesParseResultSuccessImpl &&
            const DeepCollectionEquality()
                .equals(other._namesList, _namesList));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_namesList));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ParcelNamesParseResultSuccessImplCopyWith<
          _$ParcelNamesParseResultSuccessImpl>
      get copyWith => __$$ParcelNamesParseResultSuccessImplCopyWithImpl<
          _$ParcelNamesParseResultSuccessImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> namesList) success,
    required TResult Function(ParcelNamesError reason) error,
  }) {
    return success(namesList);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> namesList)? success,
    TResult? Function(ParcelNamesError reason)? error,
  }) {
    return success?.call(namesList);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> namesList)? success,
    TResult Function(ParcelNamesError reason)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(namesList);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ParcelNamesParseResultSuccess value) success,
    required TResult Function(ParcelNamesParseResultError value) error,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ParcelNamesParseResultSuccess value)? success,
    TResult? Function(ParcelNamesParseResultError value)? error,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ParcelNamesParseResultSuccess value)? success,
    TResult Function(ParcelNamesParseResultError value)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class ParcelNamesParseResultSuccess implements ParcelNamesParseResult {
  const factory ParcelNamesParseResultSuccess(
          {required final List<String> namesList}) =
      _$ParcelNamesParseResultSuccessImpl;

  List<String> get namesList;
  @JsonKey(ignore: true)
  _$$ParcelNamesParseResultSuccessImplCopyWith<
          _$ParcelNamesParseResultSuccessImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ParcelNamesParseResultErrorImplCopyWith<$Res> {
  factory _$$ParcelNamesParseResultErrorImplCopyWith(
          _$ParcelNamesParseResultErrorImpl value,
          $Res Function(_$ParcelNamesParseResultErrorImpl) then) =
      __$$ParcelNamesParseResultErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ParcelNamesError reason});
}

/// @nodoc
class __$$ParcelNamesParseResultErrorImplCopyWithImpl<$Res>
    extends _$ParcelNamesParseResultCopyWithImpl<$Res,
        _$ParcelNamesParseResultErrorImpl>
    implements _$$ParcelNamesParseResultErrorImplCopyWith<$Res> {
  __$$ParcelNamesParseResultErrorImplCopyWithImpl(
      _$ParcelNamesParseResultErrorImpl _value,
      $Res Function(_$ParcelNamesParseResultErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? reason = null,
  }) {
    return _then(_$ParcelNamesParseResultErrorImpl(
      reason: null == reason
          ? _value.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as ParcelNamesError,
    ));
  }
}

/// @nodoc

class _$ParcelNamesParseResultErrorImpl
    with DiagnosticableTreeMixin
    implements ParcelNamesParseResultError {
  const _$ParcelNamesParseResultErrorImpl({required this.reason});

  @override
  final ParcelNamesError reason;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ParcelNamesParseResult.error(reason: $reason)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ParcelNamesParseResult.error'))
      ..add(DiagnosticsProperty('reason', reason));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ParcelNamesParseResultErrorImpl &&
            (identical(other.reason, reason) || other.reason == reason));
  }

  @override
  int get hashCode => Object.hash(runtimeType, reason);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ParcelNamesParseResultErrorImplCopyWith<_$ParcelNamesParseResultErrorImpl>
      get copyWith => __$$ParcelNamesParseResultErrorImplCopyWithImpl<
          _$ParcelNamesParseResultErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> namesList) success,
    required TResult Function(ParcelNamesError reason) error,
  }) {
    return error(reason);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> namesList)? success,
    TResult? Function(ParcelNamesError reason)? error,
  }) {
    return error?.call(reason);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> namesList)? success,
    TResult Function(ParcelNamesError reason)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(reason);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ParcelNamesParseResultSuccess value) success,
    required TResult Function(ParcelNamesParseResultError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ParcelNamesParseResultSuccess value)? success,
    TResult? Function(ParcelNamesParseResultError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ParcelNamesParseResultSuccess value)? success,
    TResult Function(ParcelNamesParseResultError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class ParcelNamesParseResultError implements ParcelNamesParseResult {
  const factory ParcelNamesParseResultError(
          {required final ParcelNamesError reason}) =
      _$ParcelNamesParseResultErrorImpl;

  ParcelNamesError get reason;
  @JsonKey(ignore: true)
  _$$ParcelNamesParseResultErrorImplCopyWith<_$ParcelNamesParseResultErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}
